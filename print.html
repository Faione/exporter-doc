<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>exporter-doc</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="01_metric.html"><strong aria-hidden="true">1.</strong> Metric</a></li><li class="chapter-item expanded "><a href="02_client.html"><strong aria-hidden="true">2.</strong> Client</a></li><li class="chapter-item expanded "><a href="03_exporter.html"><strong aria-hidden="true">3.</strong> Exporter</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">exporter-doc</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Faione/exporter-doc" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="metric"><a class="header" href="#metric">Metric</a></h1>
<ul>
<li><a href="01_metric.html#metric">Metric</a>
<ul>
<li><a href="01_metric.html#%E4%B8%80%E6%A0%BC%E5%BC%8F">一、格式</a></li>
<li><a href="01_metric.html#%E4%BA%8C%E7%B1%BB%E5%9E%8B">二、类型</a>
<ul>
<li><a href="01_metric.html#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B">基本类型</a></li>
<li><a href="01_metric.html#vec%E7%B1%BB%E5%9E%8B">Vec类型</a></li>
<li><a href="01_metric.html#untyped%E7%B1%BB%E5%9E%8B">Untyped类型</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="一格式"><a class="header" href="#一格式">一、格式</a></h2>
<p>metric格式<sup class="footnote-reference"><a href="#1">1</a></sup>一般为 <code>&lt;name&gt; {&lt;label&gt;} &lt;value&gt;</code>，主要由三部分组成</p>
<ul>
<li>name: 名称，通常用来唯一标识某一指标，并能一定程度上表达指标的含义，如<code>http_requests_total</code>表明此指标为http请求的总量</li>
<li>labels: 标签，是一组 key=&quot;value&quot; 对，为同一个指标提供多维度的信息，可以选择其中的一个或多个维度来对指标进行筛选</li>
<li>value：值，通常为整数或浮点数，exporter在抓取数据的时候对value进行更新，而name和lalels通常是静态的文本描述信息</li>
</ul>
<pre><code>my_metric{label=&quot;a&quot;} 1
</code></pre>
<h2 id="二类型"><a class="header" href="#二类型">二、类型</a></h2>
<h3 id="基本类型"><a class="header" href="#基本类型">基本类型</a></h3>
<p>Metric有四种类型<sup class="footnote-reference"><a href="#2">2</a></sup>, Counter、Gauge、Histogram和Summary，用于不同数值特征的数据<sup class="footnote-reference"><a href="#3">3</a></sup></p>
<p><strong>Counter</strong></p>
<p>基础类型，表示单个单调递增的单个数值类型，对应的value只能增加或是通过重启程序来清0，如请求的次数，完成任务的数量，错误数量等</p>
<p><img src="2023-03-16-17-38-15.png" alt="" /></p>
<p><strong>Guage</strong></p>
<p>基础类型，表示单个数值类型，但能够任意的增加或减少，如当前的温度，内存使用，并发请求的数量等</p>
<p><img src="2023-03-16-17-38-25.png" alt="" /></p>
<p><strong>Histogram</strong>: </p>
<p>复合类型，Histogram对数据进行采样，并在可配置的buckets中进行计数，同时还提供所有采样值的总和。Histogram并不保存单个数值类型指标的所有值，而对单个数值类型指标的值进一步统计，因此也是一个复合指标，基于设置的base_name, 衍生出了三个子指标<sup class="footnote-reference"><a href="#4">4</a></sup>:</p>
<ul>
<li><code>base_name_bucket{le=&quot;&lt;upper inclusive bound&gt;&quot;}</code>: Counter类型, lower or equal, 保存小于或等于bucket上界的采样值的数量</li>
<li><code>base_name_totoal_count</code>: Counter类型, 保存采样数量(次数)，也即<code>base_name_bucket{le=&quot;inf&quot;}</code> 的值</li>
<li><code>base_name_totoal_sum</code>: Counter类型, 保存采样值之和</li>
</ul>
<p><img src="2023-03-16-17-38-41.png" alt="" /></p>
<p><strong>Summary</strong></p>
<p>复合类型, Summay与Histogram类似，同样是一个复合指标，衍生了三个子指标</p>
<ul>
<li><code>base_name{quantile=&quot;0.5&quot;}</code>: 保存Summary采样周期内，50分位采样值</li>
<li><code>base_name_totoal_count</code>: Counter类型，保存采样次数</li>
<li><code>base_name_totoal_sum</code>: Counter类型，保存采样值之和</li>
</ul>
<p>默认情况下， Summary会在内存中创建10个quantile objects<sup class="footnote-reference"><a href="#5">5</a></sup>，所有的observation(采样值)会送往每个quantile objects, 而每个quantile object会在上一个object开始1min之后才开始追踪observation，这意味者最早的quantile object会保存最近10min的采样数据，随后是9，8...2,1min，而在此之后，最久的object会被移除，然后一个新的quantile object会开始追踪。显然，如果在采样周期内(10min)，没有任何数据被采样到，则<code>base_name{quantile=&quot;x&quot;}</code>的结果将会是<code>NaN</code></p>
<p><strong>Histogram Or Summary</strong></p>
<p>由于Summary会在采集时进行计算，应此会往往占用更多采集端的资源，且由于quantile百分比已经计算好，因此难以与其他节点数据进行计算;与之相反，通过histogram计算quantile数据依赖函数<code>histogram_quantile()</code>, 因此在query处会消耗更多资源，造成响应不及时，而好处在于采集端资源消耗低，易于与其他节点的数据聚合<sup class="footnote-reference"><a href="#6">6</a></sup></p>
<h3 id="vec类型"><a class="header" href="#vec类型">Vec类型</a></h3>
<p>每种基本类型都有对应的Vec类型, Vec类型保存同一基本类型的指标向量，这些指标类型相同，基础信息如<code>metric_name</code>, <code>label_key</code>, <code>description</code>等都相同，只是在个别 <code>label_value</code> 上存在差异。Vec类型提供了非常便捷的方式去定义一组相似基本指标，当设置不同的<code>label_value</code>时能够动态地创建新指标</p>
<h3 id="untyped类型"><a class="header" href="#untyped类型">Untyped类型</a></h3>
<p>当抓取的数据数值特征不明显时，可使用 Untyped </p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p><a href="https://prometheus.io/docs/instrumenting/writing_exporters/">metric_format</a></p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p><a href="https://prometheus.io/docs/concepts/metric_types/">metric_types</a></p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p><a href="https://prometheus.io/docs/tutorials/understanding_metric_types/">understanding_metric_types</a></p>
</div>
<div class="footnote-definition" id="4"><sup class="footnote-definition-label">4</sup>
<p><a href="https://www.robustperception.io/how-does-a-prometheus-histogram-work/">how_histogram_work</a></p>
</div>
<div class="footnote-definition" id="5"><sup class="footnote-definition-label">5</sup>
<p><a href="https://www.robustperception.io/how-does-a-prometheus-summary-work/">how_summary_work</a></p>
</div>
<div class="footnote-definition" id="6"><sup class="footnote-definition-label">6</sup>
<p><a href="https://bryce.fisher-fleig.org/prometheus-histograms/">histogram_or_summary</a></p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="client"><a class="header" href="#client">Client</a></h1>
<ul>
<li><a href="02_client.html#client">Client</a>
<ul>
<li><a href="02_client.html#%E4%B8%80desc--metric">一、Desc &amp; Metric</a></li>
<li><a href="02_client.html#%E4%BA%8Cbasic-metric">二、Basic Metric</a>
<ul>
<li><a href="02_client.html#collector">Collector</a></li>
<li><a href="02_client.html#basic-collector">Basic Collector</a></li>
<li><a href="02_client.html#collector-vector">Collector Vector</a></li>
</ul>
</li>
<li><a href="02_client.html#%E4%B8%89registry">三、Registry</a>
<ul>
<li><a href="02_client.html#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a></li>
<li><a href="02_client.html#register">Register</a></li>
<li><a href="02_client.html#gather">Gather</a></li>
</ul>
</li>
<li><a href="02_client.html#%E5%9B%9Bpromhandler">四、PromHandler</a></li>
</ul>
</li>
</ul>
<h2 id="一desc--metric"><a class="header" href="#一desc--metric">一、Desc &amp; Metric</a></h2>
<blockquote>
<p>Desc是Prometheus指标中使用的描述符，可以看作是Metric的不可变元数据，包含了Metric的名称、帮助文本、标签以及类型等信息
Desc 在创建 Metric 时被初始化，并在此后一直保持不变。它是 Metric 的唯一标识符，用于区分不同的指标。因此，我们可以通过 Desc 来查询和操作 Metric。
需要注意的是，Desc 只是 Metric 的元数据，它并不包含任何数据点。实际上，Metric 的值是由采集器（Collector）生成的，并存储在时间序列（Time Series）中。每个 Time Series 都包含一个具体的值和一组标签，这些标签可以对 Metric 进行分类和筛选。
总之，Desc 是 Prometheus Metric 不可或缺的组成部分，它提供了 Metric 的基本信息和结构定义，为采集器和监控系统提供了统一的接口和语义
fqName: fully-qualified name</p>
</blockquote>
<p>用户通过设置 <code>NewDesc</code> 创建 Desc, <code>id</code>、<code>dimHash</code>、<code>err</code>则由prometheus生成，其中</p>
<ul>
<li>id: 是 <code>fqName</code> 与 <code>ConstLabels Value</code> 的hash, 作为 <code>Desc</code> 的唯一标识符, 这意味着即便 <code>fqName</code> 相同，但 <code>ConstLabel Values</code> 不同的指标id不相同</li>
<li>dimHash: 是 <code>ConstLabels Name</code> 、<code>VariableLabels Name</code> 及 <code>Help</code> 的hash, 相同 <code>fqName</code> 的 Desc 必须有相同的 dimHash，即只要 <code>fqName</code> 相同，Label的组成必然是一样的</li>
<li>err: <code>NewDesc</code> 并不会返回错误，而是保存错误信息，在Register时进行处理</li>
</ul>
<pre><code class="language-go">func NewDesc(fqName, help string, variableLabels []string, constLabels Labels) *Desc

type Desc struct {
	// fqName has been built from Namespace, Subsystem, and Name.
	fqName string
	// help provides some helpful information about this metric.
	help string
	// constLabelPairs contains precalculated DTO label pairs based on
	// the constant labels.
	constLabelPairs []*dto.LabelPair
	// variableLabels contains names of labels for which the metric
	// maintains variable values.
	variableLabels []string
	// id is a hash of the values of the ConstLabels and fqName. This
	// must be unique among all registered descriptors and can therefore be
	// used as an identifier of the descriptor.
	id uint64
	// dimHash is a hash of the label names (preset and variable) and the
	// Help string. Each Desc with the same fqName must have the same
	// dimHash.
	dimHash uint64
	// err is an error that occurred during construction. It is reported on
	// registration time.
	err error
}
</code></pre>
<p>Metric 是一个接口，采集时调用 <code>Write</code> 将编码好的 Metric 数据写入到 <code>*dto.Metric</code> 中</p>
<pre><code class="language-go">type Metric interface {
	// Desc returns the descriptor for the Metric. This method idempotently
	// returns the same descriptor throughout the lifetime of the
	// Metric. The returned descriptor is immutable by contract. A Metric
	// unable to describe itself must return an invalid descriptor (created
	// with NewInvalidDesc).
	Desc() *Desc
	// Write encodes the Metric into a &quot;Metric&quot; Protocol Buffer data
	// transmission object.
	//
	// Metric implementations must observe concurrency safety as reads of
	// this metric may occur at any time, and any blocking occurs at the
	// expense of total performance of rendering all registered
	// metrics. Ideally, Metric implementations should support concurrent
	// readers.
	//
	// While populating dto.Metric, it is the responsibility of the
	// implementation to ensure validity of the Metric protobuf (like valid
	// UTF-8 strings or syntactically valid metric and label names). It is
	// recommended to sort labels lexicographically. Callers of Write should
	// still make sure of sorting if they depend on it.
	Write(*dto.Metric) error
	// TODO(beorn7): The original rationale of passing in a pre-allocated
	// dto.Metric protobuf to save allocations has disappeared. The
	// signature of this method should be changed to &quot;Write() (*dto.Metric,
	// error)&quot;.
}
</code></pre>
<h2 id="二basic-metric"><a class="header" href="#二basic-metric">二、Basic Metric</a></h2>
<h3 id="collector"><a class="header" href="#collector">Collector</a></h3>
<p><code>Collector</code> 接口是 prometheus 客户端库提供的一个接口，用于描述如何采集指标数据，并将其暴露给 Prometheus 服务器。该接口定义了以下方法：</p>
<p>Describe(chan&lt;- *Desc)：将该 collector 添加的指标的 metadata（如名称、帮助信息、标签等）发送到 chan&lt;- *Desc 中
Collect(chan&lt;- Metric)：将该 collector 表示的指标数据发送到 chan&lt;- Metric 中</p>
<pre><code class="language-go">// prometheus/collector.go #27

// Collector is the interface implemented by anything that can be used by
// Prometheus to collect metrics. A Collector has to be registered for
// collection. See Registerer.Register.
//
// The stock metrics provided by this package (Gauge, Counter, Summary,
// Histogram, Untyped) are also Collectors (which only ever collect one metric,
// namely itself). An implementer of Collector may, however, collect multiple
// metrics in a coordinated fashion and/or create metrics on the fly. Examples
// for collectors already implemented in this library are the metric vectors
// (i.e. collection of multiple instances of the same Metric but with different
// label values) like GaugeVec or SummaryVec, and the ExpvarCollector.
type Collector interface {
	// Describe sends the super-set of all possible descriptors of metrics
	// collected by this Collector to the provided channel and returns once
	// the last descriptor has been sent. The sent descriptors fulfill the
	// consistency and uniqueness requirements described in the Desc
	// documentation.
	//
	// It is valid if one and the same Collector sends duplicate
	// descriptors. Those duplicates are simply ignored. However, two
	// different Collectors must not send duplicate descriptors.
	//
	// Sending no descriptor at all marks the Collector as “unchecked”,
	// i.e. no checks will be performed at registration time, and the
	// Collector may yield any Metric it sees fit in its Collect method.
	//
	// This method idempotently sends the same descriptors throughout the
	// lifetime of the Collector. It may be called concurrently and
	// therefore must be implemented in a concurrency safe way.
	//
	// If a Collector encounters an error while executing this method, it
	// must send an invalid descriptor (created with NewInvalidDesc) to
	// signal the error to the registry.
	Describe(chan&lt;- *Desc)
	// Collect is called by the Prometheus registry when collecting
	// metrics. The implementation sends each collected metric via the
	// provided channel and returns once the last metric has been sent. The
	// descriptor of each sent metric is one of those returned by Describe
	// (unless the Collector is unchecked, see above). Returned metrics that
	// share the same descriptor must differ in their variable label
	// values.
	//
	// This method may be called concurrently and must therefore be
	// implemented in a concurrency safe way. Blocking occurs at the expense
	// of total performance of rendering all registered metrics. Ideally,
	// Collector implementations support concurrent readers.
	Collect(chan&lt;- Metric)
}
</code></pre>
<h3 id="basic-collector"><a class="header" href="#basic-collector">Basic Collector</a></h3>
<p>prometheus 提供了 <code>Counter</code>, <code>Guage</code>, <code>Histogram</code>, <code>Summary</code> 四个基本指标，他们都实现了 Collector 接口, 主要由 Desc 和 观测值 组成，包含以下特征: </p>
<ul>
<li>仅对外提供一套接口方法，通过封装私有变量的方式来控制对观测值的操作</li>
<li><code>Histogram</code> 和 <code>Summary</code> 是对观测值的进一步统计，相比于只记录单一观测值的 <code>Counter</code>, <code>Guage</code> 而言更加复杂, 实质是一种复合指标</li>
</ul>
<p>如在 gauge 中, desc 是描述符，valBits 保存了观测值比特值，selfCollector 是一个匿名结构体，提供了 Collector 的通用实现，gauge 本身只是实现了 Metric 接口，由于嵌入了 selfCollector 因此也继承了 Collector 的实现</p>
<pre><code class="language-go">type gauge struct {
	valBits uint64
    desc     *Desc
	selfCollector
	...
}
</code></pre>
<p>prometheus client 中的 Metric 都是线程安全的，底层通过 atomic 来保证并发访问的正确性</p>
<ul>
<li>Go 中并没有提供对 float64 的原子操作函数，因此Client中使用了自旋锁了操作 uint64 变量，并通过 math 库来进行 float64 与 uint64 之间的转换</li>
</ul>
<pre><code class="language-go">func (g *gauge) Add(val float64) {
	for {
		oldBits := atomic.LoadUint64(&amp;g.valBits)
		newBits := math.Float64bits(math.Float64frombits(oldBits) + val)
		if atomic.CompareAndSwapUint64(&amp;g.valBits, oldBits, newBits) {
			return
		}
	}
}
</code></pre>
<h3 id="collector-vector"><a class="header" href="#collector-vector">Collector Vector</a></h3>
<p>Vector Collector 维护了一个 Metric 集合，这些 Metric 共享相同的 Desc, 通过不同的 VariableLabel Values 进行区分， 可使用 <code>WithLabelValues</code>， 来插入一个新的 Metric 或对一个已有的 Metric 进行更新</p>
<h2 id="三registry"><a class="header" href="#三registry">三、Registry</a></h2>
<h3 id="数据结构"><a class="header" href="#数据结构">数据结构</a></h3>
<p>Registry是Registerer接口的一个实现，负责注册Prometheus collectors, 收集metrics来构造MetricFamilies进行暴露</p>
<blockquote>
<p>一个 Collector 中可以存在多个不同的 Desc, 将这些 Desc 的 ID 进行异或来得到 CollectorID</p>
</blockquote>
<p>Registry中包含三个主要的map：</p>
<ul>
<li>collectorsByID: 保存 CollectID 到 Collector 的映射</li>
<li>descIDs：保存所有 DescID 的集合, 用来判断 Desc 是否重复</li>
<li>dimHashesByName：保存 fqName 到 dimHash 的映射，判断 Desc 是否合法，即相同 fqName 的 Desc, dimHash 必须相同</li>
</ul>
<pre><code class="language-go">type Registry struct {
	collectorsByID        map[uint64]Collector 
	descIDs               map[uint64]struct{}
	dimHashesByName       map[string]uint64
	...
}
</code></pre>
<h3 id="register"><a class="header" href="#register">Register</a></h3>
<p><code>Register</code> 将 Collector 注册到 metric family 中, 其中会调用 <code>Collector</code> 的 <code>Describe</code> 方法获取 Desc 来验证 Collector 的合法性以及是否重复</p>
<p><code>Collector</code> 也可以在 <code>Describe</code> 中返回空值，这样 <code>Register</code> 就会跳过验证过程，这样的 Collecotr 被称为 Unchecked Collector, 它们的注册总是会成功并直接加入到一个Unchecked Collector列表中，这要求开发者保证每个 <code>Collector</code> 的唯一性，以避免出现抓取错误</p>
<blockquote>
<p>Register 中的验证是以 Collector 为粒度的，因此会允许 Desc 在同一个 Collector 内重复，而在 Collector 之间这样则会返回错误</p>
</blockquote>
<p>Collector 验证过程:</p>
<ol>
<li>集中处理 Desc 构建时的错误</li>
<li>判断 Desc 是否与之前注册的 Collector 的 Desc 重复</li>
<li>收集 Collector 中非重复的 Desc, 将ID相异或得到 CollectorID</li>
<li>判断相同 fqName 的 Desc, dimHash(label组成)是否相同</li>
</ol>
<p>验证过程结束后，CollectorID 也构造完成，因此在 Register最后部分，就会对 Collector 进行重复判断，并更新 <code>collectorsByID</code>，<code>descIDs</code> 与 <code>dimHashesByName</code></p>
<pre><code class="language-go">// prometheus/promhttp/registry.go #291
// Is the descriptor valid at all?
if desc.err != nil {
	return fmt.Errorf(&quot;descriptor %s is invalid: %w&quot;, desc, desc.err)
}

// Is the descID unique?
// (In other words: Is the fqName + constLabel combination unique?)
if _, exists := r.descIDs[desc.id]; exists {
	duplicateDescErr = fmt.Errorf(&quot;descriptor %s already exists with the same fully-qualified name and const label values&quot;, desc)
}
// If it is not a duplicate desc in this collector, XOR it to
// the collectorID.  (We allow duplicate descs within the same
// collector, but their existence must be a no-op.)
if _, exists := newDescIDs[desc.id]; !exists {
	newDescIDs[desc.id] = struct{}{}
	collectorID ^= desc.id
}

// Are all the label names and the help string consistent with
// previous descriptors of the same name?
// First check existing descriptors...
if dimHash, exists := r.dimHashesByName[desc.fqName]; exists {
	if dimHash != desc.dimHash {
		return fmt.Errorf(&quot;a previously registered descriptor with the same fully-qualified name as %s has different label names or a different help string&quot;, desc)
	}
} else {
	// ...then check the new descriptors already seen.
	if dimHash, exists := newDimHashesByName[desc.fqName]; exists {
		if dimHash != desc.dimHash {
			return fmt.Errorf(&quot;descriptors reported by collector have inconsistent label names or help strings for the same fully-qualified name, offender is %s&quot;, desc)
		}
	} else {
		newDimHashesByName[desc.fqName] = desc.dimHash
	}
}
</code></pre>
<h3 id="gather"><a class="header" href="#gather">Gather</a></h3>
<p><code>Gather</code> 方法会调用所有已注册的 Collector 的 Collect 方法，并将收集到的指标聚合成一个字典序且无重复的MetricFamily protobuf切片</p>
<p><code>Gather</code> 会尽可能地收集指标，即便有些 Collect 返回的是空值</p>
<p>每个 Metric 都需要经过从 Collector 采集，然后再经过 <code>processMetric</code> 处理为可编码的格式并保存到 <code>[]*dto.MetricFamily</code> 中, 考虑到会同时存在多个Collector, 每个Collector采集 Metric 的速度都不同，简单地，可以为每个 Collector 创建一个协程来处理，但是这样并不一定高效，因为协程的创建与回收都会消耗一定的资源</p>
<p>Gather 内部会进行一定的协程调度，尽可能用最少的协程来满足采集需求，而为实现这一目的，主要经过以下操作:</p>
<ol>
<li>创建好 Metric 管道，计算当前所有的Collector数量，设置为可开启的协程上限</li>
<li>将 Collector 存放到 channel 中，并创建好 waitGroup 来进行并发控制</li>
<li>启动collectWorker，其中会不断地从管道取出 collector 并执行 Collect 方法</li>
<li>主函数中则不断地从 Metric 管道中读取 Metric 进行处理，而当metric消费速度超过生产速度时，则会根据协程上限与剩余 Collector 的数量，来决定是否增加新的 collectWorker</li>
</ol>
<pre><code class="language-go">collectWorker := func() {
	for {
		select {
		case collector := &lt;-checkedCollectors:
			collector.Collect(checkedMetricChan)
		case collector := &lt;-uncheckedCollectors:
			collector.Collect(uncheckedMetricChan)
		default:
			return
		}
		wg.Done()
	}
}
</code></pre>
<h2 id="四promhandler"><a class="header" href="#四promhandler">四、PromHandler</a></h2>
<p>四、PromHandler 主要逻辑: </p>
<ol>
<li>调用 Registry 的 <code>Gather</code> 方法，收集所有 Collector 的指标</li>
<li>随后构造 Metric 编码器，能够编码 Metric，同时传入 Response 用来写入编码后的 Metric</li>
<li>调用编码器逐个对 Metric 进行处理并写入 Response 中</li>
</ol>
<pre><code class="language-go">// prometheus/promhttp/http.go

// #135 调用Gather()方法收集metric
mfs, done, err := reg.Gather()
defer done()
...

// #166 enc负责将metric编码为字符串并写入到返回值中
w := io.Writer(rsp)
...
enc := expfmt.NewEncoder(w, contentType)

...

// #204 逐个编码 metric并向rsp写入
for _, mf := range mfs {
	if handleError(enc.Encode(mf)) {
		return
	}
}
...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exporter"><a class="header" href="#exporter">Exporter</a></h1>
<ul>
<li><a href="03_exporter.html#exporter">Exporter</a>
<ul>
<li><a href="03_exporter.html#simple-exporter">Simple Exporter</a></li>
<li><a href="03_exporter.html#%E5%9F%BA%E6%9C%AC%E8%8C%83%E5%BC%8F">基本范式</a></li>
</ul>
</li>
</ul>
<h2 id="simple-exporter"><a class="header" href="#simple-exporter">Simple Exporter</a></h2>
<pre><code class="language-go">// collector.go
type SimpleCollector{}

var simpleDesc =  prometheus.NewDesc(
			prometheus.BuildFQName(&quot;demo&quot;, &quot;foo&quot;, &quot;bar&quot;),
			&quot;Simple collector&quot;,
			[]string{&quot;lable_foo&quot;}, nil,
		)

func (s SimpleCollector) Describe(ch chan&lt;- *prometheus.Desc) {
	ch &lt;- simpleDesc
}

func (s SimpleCollector) Collect(ch chan&lt;- prometheus.Metric) {
	ch &lt;- prometheus.MustNewConstMetric(
		simpleDesc,
		prometheus.CounterValue,
		1,
		&quot;value_foo&quot;,
	)
}

// main.go
func main() {
	// 创建 prometheus registry，用来注册 Collector
	rg := prometheus.NewRegistry()
	rg.MustRegister(SimpleCollector{})

	// 创建 promHandler, 用来处理 metrics 请求
	promHandler := promhttp.HandlerFor(
	rg,
	promhttp.HandlerOpts{
		ErrorLog:            logger,
		MaxRequestsInFlight: maxRequests,
	},

	http.Handle(&quot;/metrics&quot;, promHandler)
	server := &amp;http.Server{Addr: &quot;:9900&quot;}

	if err := server.ListenAndServe(); err != nil {
		os.Exit(1)
	}
)
}
</code></pre>
<p><img src="./img/tiny_exporter.svg" alt="" /></p>
<h2 id="基本范式"><a class="header" href="#基本范式">基本范式</a></h2>
<ol>
<li>编写Collector实现 <code>prometheus.Collector</code> 接口</li>
<li>使用 <code>promethues.MustRegister()</code> 方法将Collector注册到prometheus registry中</li>
<li>创建 server, 并添加 <code>promhttp.Handler()</code> 方法</li>
<li>每次请求会在 <code>promHandler</code> 中进行处理，简单而言，handler 中会首先创建几个管道，用来保存一些metric/desc数据，然后调用registry中所有Collector的<code>Describe</code>,<code>Collect</code> 方法来获取指标相关的信息，并最后将其序列化返回</li>
</ol>
<p>使用<code>promhttp.Handler</code>作为采集入口时，会额外地采集请求处理过程中的性能数据，如果要关闭这些数据，可以使用<code>promhttp.HandlerFor</code>作为替换oo</p>
<pre><code class="language-go">rg := prometheus.NewRegistry()
rg.MustRegister(serverCollector)

http.Handle(metricsPath, promhttp.HandlerFor(rg, promhttp.HandlerOpts{ErrorLog: logger}))
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
