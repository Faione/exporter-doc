<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Client - exporter-doc</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="01_metric.html"><strong aria-hidden="true">1.</strong> Metric</a></li><li class="chapter-item expanded "><a href="02_client.html" class="active"><strong aria-hidden="true">2.</strong> Client</a></li><li class="chapter-item expanded "><a href="03_exporter.html"><strong aria-hidden="true">3.</strong> Exporter</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">exporter-doc</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Faione/exporter-doc" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="client"><a class="header" href="#client">Client</a></h1>
<ul>
<li><a href="#client">Client</a>
<ul>
<li><a href="#%E4%B8%80desc--metric">一、Desc &amp; Metric</a></li>
<li><a href="#%E4%BA%8Cbasic-metric">二、Basic Metric</a>
<ul>
<li><a href="#collector">Collector</a></li>
<li><a href="#basic-collector">Basic Collector</a></li>
<li><a href="#collector-vector">Collector Vector</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89registry">三、Registry</a>
<ul>
<li><a href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a></li>
<li><a href="#register">Register</a></li>
<li><a href="#gather">Gather</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9Bpromhandler">四、PromHandler</a></li>
</ul>
</li>
</ul>
<h2 id="一desc--metric"><a class="header" href="#一desc--metric">一、Desc &amp; Metric</a></h2>
<blockquote>
<p>Desc是Prometheus指标中使用的描述符，可以看作是Metric的不可变元数据，包含了Metric的名称、帮助文本、标签以及类型等信息
Desc 在创建 Metric 时被初始化，并在此后一直保持不变。它是 Metric 的唯一标识符，用于区分不同的指标。因此，我们可以通过 Desc 来查询和操作 Metric。
需要注意的是，Desc 只是 Metric 的元数据，它并不包含任何数据点。实际上，Metric 的值是由采集器（Collector）生成的，并存储在时间序列（Time Series）中。每个 Time Series 都包含一个具体的值和一组标签，这些标签可以对 Metric 进行分类和筛选。
总之，Desc 是 Prometheus Metric 不可或缺的组成部分，它提供了 Metric 的基本信息和结构定义，为采集器和监控系统提供了统一的接口和语义
fqName: fully-qualified name</p>
</blockquote>
<p>用户通过设置 <code>NewDesc</code> 创建 Desc, <code>id</code>、<code>dimHash</code>、<code>err</code>则由prometheus生成，其中</p>
<ul>
<li>id: 是 <code>fqName</code> 与 <code>ConstLabels Value</code> 的hash, 作为 <code>Desc</code> 的唯一标识符, 这意味着即便 <code>fqName</code> 相同，但 <code>ConstLabel Values</code> 不同的指标id不相同</li>
<li>dimHash: 是 <code>ConstLabels Name</code> 、<code>VariableLabels Name</code> 及 <code>Help</code> 的hash, 相同 <code>fqName</code> 的 Desc 必须有相同的 dimHash，即只要 <code>fqName</code> 相同，Label的组成必然是一样的</li>
<li>err: <code>NewDesc</code> 并不会返回错误，而是保存错误信息，在Register时进行处理</li>
</ul>
<pre><code class="language-go">func NewDesc(fqName, help string, variableLabels []string, constLabels Labels) *Desc

type Desc struct {
	// fqName has been built from Namespace, Subsystem, and Name.
	fqName string
	// help provides some helpful information about this metric.
	help string
	// constLabelPairs contains precalculated DTO label pairs based on
	// the constant labels.
	constLabelPairs []*dto.LabelPair
	// variableLabels contains names of labels for which the metric
	// maintains variable values.
	variableLabels []string
	// id is a hash of the values of the ConstLabels and fqName. This
	// must be unique among all registered descriptors and can therefore be
	// used as an identifier of the descriptor.
	id uint64
	// dimHash is a hash of the label names (preset and variable) and the
	// Help string. Each Desc with the same fqName must have the same
	// dimHash.
	dimHash uint64
	// err is an error that occurred during construction. It is reported on
	// registration time.
	err error
}
</code></pre>
<p>Metric 是一个接口，采集时调用 <code>Write</code> 将编码好的 Metric 数据写入到 <code>*dto.Metric</code> 中</p>
<pre><code class="language-go">type Metric interface {
	// Desc returns the descriptor for the Metric. This method idempotently
	// returns the same descriptor throughout the lifetime of the
	// Metric. The returned descriptor is immutable by contract. A Metric
	// unable to describe itself must return an invalid descriptor (created
	// with NewInvalidDesc).
	Desc() *Desc
	// Write encodes the Metric into a &quot;Metric&quot; Protocol Buffer data
	// transmission object.
	//
	// Metric implementations must observe concurrency safety as reads of
	// this metric may occur at any time, and any blocking occurs at the
	// expense of total performance of rendering all registered
	// metrics. Ideally, Metric implementations should support concurrent
	// readers.
	//
	// While populating dto.Metric, it is the responsibility of the
	// implementation to ensure validity of the Metric protobuf (like valid
	// UTF-8 strings or syntactically valid metric and label names). It is
	// recommended to sort labels lexicographically. Callers of Write should
	// still make sure of sorting if they depend on it.
	Write(*dto.Metric) error
	// TODO(beorn7): The original rationale of passing in a pre-allocated
	// dto.Metric protobuf to save allocations has disappeared. The
	// signature of this method should be changed to &quot;Write() (*dto.Metric,
	// error)&quot;.
}
</code></pre>
<h2 id="二basic-metric"><a class="header" href="#二basic-metric">二、Basic Metric</a></h2>
<h3 id="collector"><a class="header" href="#collector">Collector</a></h3>
<p><code>Collector</code> 接口是 prometheus 客户端库提供的一个接口，用于描述如何采集指标数据，并将其暴露给 Prometheus 服务器。该接口定义了以下方法：</p>
<p>Describe(chan&lt;- *Desc)：将该 collector 添加的指标的 metadata（如名称、帮助信息、标签等）发送到 chan&lt;- *Desc 中
Collect(chan&lt;- Metric)：将该 collector 表示的指标数据发送到 chan&lt;- Metric 中</p>
<pre><code class="language-go">// prometheus/collector.go #27

// Collector is the interface implemented by anything that can be used by
// Prometheus to collect metrics. A Collector has to be registered for
// collection. See Registerer.Register.
//
// The stock metrics provided by this package (Gauge, Counter, Summary,
// Histogram, Untyped) are also Collectors (which only ever collect one metric,
// namely itself). An implementer of Collector may, however, collect multiple
// metrics in a coordinated fashion and/or create metrics on the fly. Examples
// for collectors already implemented in this library are the metric vectors
// (i.e. collection of multiple instances of the same Metric but with different
// label values) like GaugeVec or SummaryVec, and the ExpvarCollector.
type Collector interface {
	// Describe sends the super-set of all possible descriptors of metrics
	// collected by this Collector to the provided channel and returns once
	// the last descriptor has been sent. The sent descriptors fulfill the
	// consistency and uniqueness requirements described in the Desc
	// documentation.
	//
	// It is valid if one and the same Collector sends duplicate
	// descriptors. Those duplicates are simply ignored. However, two
	// different Collectors must not send duplicate descriptors.
	//
	// Sending no descriptor at all marks the Collector as “unchecked”,
	// i.e. no checks will be performed at registration time, and the
	// Collector may yield any Metric it sees fit in its Collect method.
	//
	// This method idempotently sends the same descriptors throughout the
	// lifetime of the Collector. It may be called concurrently and
	// therefore must be implemented in a concurrency safe way.
	//
	// If a Collector encounters an error while executing this method, it
	// must send an invalid descriptor (created with NewInvalidDesc) to
	// signal the error to the registry.
	Describe(chan&lt;- *Desc)
	// Collect is called by the Prometheus registry when collecting
	// metrics. The implementation sends each collected metric via the
	// provided channel and returns once the last metric has been sent. The
	// descriptor of each sent metric is one of those returned by Describe
	// (unless the Collector is unchecked, see above). Returned metrics that
	// share the same descriptor must differ in their variable label
	// values.
	//
	// This method may be called concurrently and must therefore be
	// implemented in a concurrency safe way. Blocking occurs at the expense
	// of total performance of rendering all registered metrics. Ideally,
	// Collector implementations support concurrent readers.
	Collect(chan&lt;- Metric)
}
</code></pre>
<h3 id="basic-collector"><a class="header" href="#basic-collector">Basic Collector</a></h3>
<p>prometheus 提供了 <code>Counter</code>, <code>Guage</code>, <code>Histogram</code>, <code>Summary</code> 四个基本指标，他们都实现了 Collector 接口, 主要由 Desc 和 观测值 组成，包含以下特征: </p>
<ul>
<li>仅对外提供一套接口方法，通过封装私有变量的方式来控制对观测值的操作</li>
<li><code>Histogram</code> 和 <code>Summary</code> 是对观测值的进一步统计，相比于只记录单一观测值的 <code>Counter</code>, <code>Guage</code> 而言更加复杂, 实质是一种复合指标</li>
</ul>
<p>如在 gauge 中, desc 是描述符，valBits 保存了观测值比特值，selfCollector 是一个匿名结构体，提供了 Collector 的通用实现，gauge 本身只是实现了 Metric 接口，由于嵌入了 selfCollector 因此也继承了 Collector 的实现</p>
<pre><code class="language-go">type gauge struct {
	valBits uint64
    desc     *Desc
	selfCollector
	...
}
</code></pre>
<p>prometheus client 中的 Metric 都是线程安全的，底层通过 atomic 来保证并发访问的正确性</p>
<ul>
<li>Go 中并没有提供对 float64 的原子操作函数，因此Client中使用了自旋锁了操作 uint64 变量，并通过 math 库来进行 float64 与 uint64 之间的转换</li>
</ul>
<pre><code class="language-go">func (g *gauge) Add(val float64) {
	for {
		oldBits := atomic.LoadUint64(&amp;g.valBits)
		newBits := math.Float64bits(math.Float64frombits(oldBits) + val)
		if atomic.CompareAndSwapUint64(&amp;g.valBits, oldBits, newBits) {
			return
		}
	}
}
</code></pre>
<h3 id="collector-vector"><a class="header" href="#collector-vector">Collector Vector</a></h3>
<p>Vector Collector 维护了一个 Metric 集合，这些 Metric 共享相同的 Desc, 通过不同的 VariableLabel Values 进行区分， 可使用 <code>WithLabelValues</code>， 来插入一个新的 Metric 或对一个已有的 Metric 进行更新</p>
<h2 id="三registry"><a class="header" href="#三registry">三、Registry</a></h2>
<h3 id="数据结构"><a class="header" href="#数据结构">数据结构</a></h3>
<p>Registry是Registerer接口的一个实现，负责注册Prometheus collectors, 收集metrics来构造MetricFamilies进行暴露</p>
<blockquote>
<p>一个 Collector 中可以存在多个不同的 Desc, 将这些 Desc 的 ID 进行异或来得到 CollectorID</p>
</blockquote>
<p>Registry中包含三个主要的map：</p>
<ul>
<li>collectorsByID: 保存 CollectID 到 Collector 的映射</li>
<li>descIDs：保存所有 DescID 的集合, 用来判断 Desc 是否重复</li>
<li>dimHashesByName：保存 fqName 到 dimHash 的映射，判断 Desc 是否合法，即相同 fqName 的 Desc, dimHash 必须相同</li>
</ul>
<pre><code class="language-go">type Registry struct {
	collectorsByID        map[uint64]Collector 
	descIDs               map[uint64]struct{}
	dimHashesByName       map[string]uint64
	...
}
</code></pre>
<h3 id="register"><a class="header" href="#register">Register</a></h3>
<p><code>Register</code> 将 Collector 注册到 metric family 中, 其中会调用 <code>Collector</code> 的 <code>Describe</code> 方法获取 Desc 来验证 Collector 的合法性以及是否重复</p>
<p><code>Collector</code> 也可以在 <code>Describe</code> 中返回空值，这样 <code>Register</code> 就会跳过验证过程，这样的 Collecotr 被称为 Unchecked Collector, 它们的注册总是会成功并直接加入到一个Unchecked Collector列表中，这要求开发者保证每个 <code>Collector</code> 的唯一性，以避免出现抓取错误</p>
<blockquote>
<p>Register 中的验证是以 Collector 为粒度的，因此会允许 Desc 在同一个 Collector 内重复，而在 Collector 之间这样则会返回错误</p>
</blockquote>
<p>Collector 验证过程:</p>
<ol>
<li>集中处理 Desc 构建时的错误</li>
<li>判断 Desc 是否与之前注册的 Collector 的 Desc 重复</li>
<li>收集 Collector 中非重复的 Desc, 将ID相异或得到 CollectorID</li>
<li>判断相同 fqName 的 Desc, dimHash(label组成)是否相同</li>
</ol>
<p>验证过程结束后，CollectorID 也构造完成，因此在 Register最后部分，就会对 Collector 进行重复判断，并更新 <code>collectorsByID</code>，<code>descIDs</code> 与 <code>dimHashesByName</code></p>
<pre><code class="language-go">// prometheus/promhttp/registry.go #291
// Is the descriptor valid at all?
if desc.err != nil {
	return fmt.Errorf(&quot;descriptor %s is invalid: %w&quot;, desc, desc.err)
}

// Is the descID unique?
// (In other words: Is the fqName + constLabel combination unique?)
if _, exists := r.descIDs[desc.id]; exists {
	duplicateDescErr = fmt.Errorf(&quot;descriptor %s already exists with the same fully-qualified name and const label values&quot;, desc)
}
// If it is not a duplicate desc in this collector, XOR it to
// the collectorID.  (We allow duplicate descs within the same
// collector, but their existence must be a no-op.)
if _, exists := newDescIDs[desc.id]; !exists {
	newDescIDs[desc.id] = struct{}{}
	collectorID ^= desc.id
}

// Are all the label names and the help string consistent with
// previous descriptors of the same name?
// First check existing descriptors...
if dimHash, exists := r.dimHashesByName[desc.fqName]; exists {
	if dimHash != desc.dimHash {
		return fmt.Errorf(&quot;a previously registered descriptor with the same fully-qualified name as %s has different label names or a different help string&quot;, desc)
	}
} else {
	// ...then check the new descriptors already seen.
	if dimHash, exists := newDimHashesByName[desc.fqName]; exists {
		if dimHash != desc.dimHash {
			return fmt.Errorf(&quot;descriptors reported by collector have inconsistent label names or help strings for the same fully-qualified name, offender is %s&quot;, desc)
		}
	} else {
		newDimHashesByName[desc.fqName] = desc.dimHash
	}
}
</code></pre>
<h3 id="gather"><a class="header" href="#gather">Gather</a></h3>
<p><code>Gather</code> 方法会调用所有已注册的 Collector 的 Collect 方法，并将收集到的指标聚合成一个字典序且无重复的MetricFamily protobuf切片</p>
<p><code>Gather</code> 会尽可能地收集指标，即便有些 Collect 返回的是空值</p>
<p>每个 Metric 都需要经过从 Collector 采集，然后再经过 <code>processMetric</code> 处理为可编码的格式并保存到 <code>[]*dto.MetricFamily</code> 中, 考虑到会同时存在多个Collector, 每个Collector采集 Metric 的速度都不同，简单地，可以为每个 Collector 创建一个协程来处理，但是这样并不一定高效，因为协程的创建与回收都会消耗一定的资源</p>
<p>Gather 内部会进行一定的协程调度，尽可能用最少的协程来满足采集需求，而为实现这一目的，主要经过以下操作:</p>
<ol>
<li>创建好 Metric 管道，计算当前所有的Collector数量，设置为可开启的协程上限</li>
<li>将 Collector 存放到 channel 中，并创建好 waitGroup 来进行并发控制</li>
<li>启动collectWorker，其中会不断地从管道取出 collector 并执行 Collect 方法</li>
<li>主函数中则不断地从 Metric 管道中读取 Metric 进行处理，而当metric消费速度超过生产速度时，则会根据协程上限与剩余 Collector 的数量，来决定是否增加新的 collectWorker</li>
</ol>
<pre><code class="language-go">collectWorker := func() {
	for {
		select {
		case collector := &lt;-checkedCollectors:
			collector.Collect(checkedMetricChan)
		case collector := &lt;-uncheckedCollectors:
			collector.Collect(uncheckedMetricChan)
		default:
			return
		}
		wg.Done()
	}
}
</code></pre>
<h2 id="四promhandler"><a class="header" href="#四promhandler">四、PromHandler</a></h2>
<p>四、PromHandler 主要逻辑: </p>
<ol>
<li>调用 Registry 的 <code>Gather</code> 方法，收集所有 Collector 的指标</li>
<li>随后构造 Metric 编码器，能够编码 Metric，同时传入 Response 用来写入编码后的 Metric</li>
<li>调用编码器逐个对 Metric 进行处理并写入 Response 中</li>
</ol>
<pre><code class="language-go">// prometheus/promhttp/http.go

// #135 调用Gather()方法收集metric
mfs, done, err := reg.Gather()
defer done()
...

// #166 enc负责将metric编码为字符串并写入到返回值中
w := io.Writer(rsp)
...
enc := expfmt.NewEncoder(w, contentType)

...

// #204 逐个编码 metric并向rsp写入
for _, mf := range mfs {
	if handleError(enc.Encode(mf)) {
		return
	}
}
...
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="01_metric.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="03_exporter.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="01_metric.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="03_exporter.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
